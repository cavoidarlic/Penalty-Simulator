<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Penalty Kick Simulator</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(to bottom, #87CEEB, #90EE90);
            font-family: Arial, sans-serif;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }
        
        .game-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
        }
        
        .hud {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 10px;
            padding: 15px 30px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            text-align: center;
            min-width: 300px;
        }
        
        .score-board {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 28px;
            font-weight: bold;
        }
        
        .game-info {
            margin: 5px 0;
            font-size: 20px;
            min-height: 30px;
        }
        
        .instructions {
            margin: 5px 0;
            font-size: 16px;
            color: #666;
        }
        
        #gameCanvas {
            width: 100%;
            height: 100%;
            cursor: crosshair;
            display: block;
        }
        
        .skin-button {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.9);
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            border: 2px solid #444;
            transition: transform 0.2s;
        }
        
        .skin-button:hover {
            transform: scale(1.1);
        }
        
        .skin-button-icon {
            width: 30px;
            height: 30px;
            background-color: #555;
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
        }
        
        .skin-panel {
            position: absolute;
            right: 20px;
            top: 80px;
            width: 320px;
            max-height: 80vh;
            overflow-y: auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            z-index: 100;
            display: none;
        }
        
        .skin-panel h3 {
            margin-top: 0;
            text-align: center;
            color: #444;
            border-bottom: 2px solid #ccc;
            padding-bottom: 10px;
        }
        
        .skin-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
        }
        
        .skin-item {
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            transition: transform 0.2s;
        }
        
        .skin-item:hover {
            transform: scale(1.03);
        }
        
        .skin-item.active {
            border-color: #4CAF50;
            background-color: rgba(76, 175, 80, 0.1);
        }
        
        .skin-item.locked {
            opacity: 0.7;
        }
        
        .skin-item.locked::after {
            content: 'ðŸ”’';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 30px;
            color: #ff5722;
        }
        
        .skin-preview {
            width: 100px;
            height: 100px;
            object-fit: contain;
            margin-bottom: 5px;
            background-color: #f5f5f5;
            border-radius: 5px;
        }
        
        .skin-name {
            font-weight: bold;
            text-align: center;
            margin: 5px 0;
        }
        
        .skin-requirement {
            font-size: 12px;
            color: #666;
            text-align: center;
        }
        
        .close-button {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: #666;
        }
        
        .close-button:hover {
            color: #000;
        }
        
        .stats-display {
            margin-bottom: 15px;
            padding: 10px;
            background-color: #f5f5f5;
            border-radius: 5px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="hud">
            <div class="score-board">
                <div>Team A: <span id="scoreA">0</span></div>
                <div>Team B: <span id="scoreB">0</span></div>
            </div>
            <div class="game-info" id="gameInfo">Team A's turn to kick!</div>
            <div class="instructions" id="instructions">Loading sprites...</div>
        </div>
        
        <div class="skin-button" id="skinButton">
            <div class="skin-button-icon"></div>
        </div>
        
        <div class="skin-panel" id="skinPanel">
            <button class="close-button" id="closeSkinPanel">Ã—</button>
            <h3>Player Skins</h3>
            <div class="stats-display" id="statsDisplay">
                Total Goals: <span id="totalGoals">0</span> | Saves: <span id="totalSaves">0</span>
            </div>
            <div class="skin-grid" id="skinGrid">
            </div>
        </div>
        
        <canvas id="gameCanvas"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        let scaleX = 1;
        let scaleY = 1;
        let baseWidth = 800;
        let baseHeight = 600;
        
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            scaleX = canvas.width / baseWidth;
            scaleY = canvas.height / baseHeight;
            
            updateSpritePositions();
        }
        
        function updateSpritePositions() {
            Object.keys(sprites).forEach(key => {
                sprites[key].x = sprites[key].baseX * scaleX;
                sprites[key].y = sprites[key].baseY * scaleY;
                sprites[key].width = sprites[key].baseWidth * scaleX;
                sprites[key].height = sprites[key].baseHeight * scaleY;
                sprites[key].scaledHitboxWidth = sprites[key].hitboxWidth * scaleX;
                sprites[key].scaledHitboxHeight = sprites[key].hitboxHeight * scaleY;
                sprites[key].scaledHitboxOffsetX = sprites[key].hitboxOffsetX * scaleX;
                sprites[key].scaledHitboxOffsetY = sprites[key].hitboxOffsetY * scaleY;
            });
            
            ball = { ...sprites.ball };
            keeper = { ...sprites.keeper };
            kicker = { ...sprites.kicker };
        }
        
        let playerStats = {
            totalGoals: 0,
            totalSaves: 0,
            currentSkin: 'default'
        };

        const images = {};
        const imageNames = ['theball', 'thegoal', 'thekeeper', 'thekicker'];
        let imagesLoaded = 0;

        function loadImages() {
            imageNames.forEach(name => {
                images[name] = new Image();
                images[name].onload = () => {
                    imagesLoaded++;
                    if (imagesLoaded === imageNames.length) {
                        initGame();
                    }
                };
                images[name].src = `${name}.png`;
            });
            
            if (playerStats && playerStats.currentSkin !== 'default') {
                const selectedSkin = skins.find(skin => skin.id === playerStats.currentSkin);
                if (selectedSkin) {
                    images.thekicker = new Image();
                    images.thekicker.src = selectedSkin.file;
                }
            }
        }
        
        let gameState = 'TEAM_A_KICK';
        let scoreA = 0;
        let scoreB = 0;
        let round = 1;
        const maxRounds = 5;
        
        const sprites = {
            ball: { 
                baseX: 400, baseY: 500, baseWidth: 35, baseHeight: 48,
                x: 400, y: 500, width: 35, height: 48, image: 'theball',
                hitboxWidth: 35, hitboxHeight: 48, hitboxOffsetX: 0, hitboxOffsetY: 0
            },
            goal: { 
                baseX: 200, baseY: 80, baseWidth: 400, baseHeight: 199,
                x: 200, y: 80, width: 400, height: 199, image: 'thegoal',
                hitboxWidth: 350, hitboxHeight: 150, hitboxOffsetX: 25, hitboxOffsetY: 25
            },
            keeper: { 
                baseX: 300, baseY: 90, baseWidth: 200, baseHeight: 200,
                x: 300, y: 90, width: 200, height: 200, image: 'thekeeper',
                hitboxWidth: 70, hitboxHeight: 150, hitboxOffsetX: 68, hitboxOffsetY: 40
            },
            kicker: { 
                baseX: 200, baseY: 450, baseWidth: 200, baseHeight: 517,
                x: 200, y: 450, width: 200, height: 517, image: 'thekicker',
                hitboxWidth: 200, hitboxHeight: 517, hitboxOffsetX: 0, hitboxOffsetY: 0
            }
        };
        
        let ball = { ...sprites.ball };
        let keeper = { ...sprites.keeper };
        let kicker = { ...sprites.kicker };
        
        let ballVelocity = { x: 0, y: 0 };
        let isDragging = false;
        let dragStart = { x: 0, y: 0 };
        let dragObject = null;
        let ballInMotion = false;
        let kickTimer = 0;
        let gkTimer = 0;
        let keeperDiving = false;
        let keeperDiveDirection = { x: 0, y: 0 };
        let keeperDiveSpeed = 8;
        let keeperDiveTarget = { x: 0, y: 0 };
        let keeperDiveStartY = 0;
        let keeperJumpHeight = 40;
        let keeperHasDived = false;
        let playerKeeperStartY = 0;
        let diveThreshold = 25;
        let showHitboxes = false;
        let keeperAIDirection = 1;
        let keeperAISpeed = 1.5;
        let ballStartPosition = { x: 0, y: 0 };
        let keeperHopOffset = 0;
        let keeperHopDirection = 1;
        let keeperOriginalY = 0;
        let keeperRotation = 0;
        
        const skins = [
            { id: 'default', name: 'Kylian MbappÃ©', file: 'thekicker.png', requirement: 0, type: 'kicker' },
            { id: 'ronaldo', name: 'Cristiano Ronaldo', file: 'Skin/Ronaldo.png', requirement: 0, type: 'kicker' },
            { id: 'yamal', name: 'Lamine Yamal', file: 'Skin/yamal.png', requirement: 0, type: 'kicker' },
            { id: 'haaland', name: 'Erling Haaland', file: 'Skin/Erling Haaland.png', requirement: 5, type: 'kicker' },
            { id: 'salah', name: 'Mohamed Salah', file: 'Skin/mohamed salah.png', requirement: 10, type: 'kicker' },
            { id: 'fernandes', name: 'Bruno Fernandes', file: 'Skin/Bruno Fernandes.png', requirement: 15, type: 'kicker' },
            { id: 'lewandowski', name: 'Robert Lewandowski', file: 'Skin/robert lewandowski.png', requirement: 20, type: 'kicker' },
            { id: 'kane', name: 'Harry Kane', file: 'Skin/harry kane.png', requirement: 25, type: 'kicker' },
            { id: 'neymar', name: 'Neymar Jr.', file: 'Skin/neymar.png', requirement: 30, type: 'kicker' },
            { id: 'messi', name: 'Lionel Messi', file: 'Skin/Lionel Messi.png', requirement: 35, type: 'kicker' }
        ];
        
        function loadPlayerStats() {
            const savedStats = localStorage.getItem('penaltyKickStats');
            if (savedStats) {
                try {
                    playerStats = JSON.parse(savedStats);
                } catch (e) {
                    console.error("Error parsing saved stats:", e);
                }
            }
            updateStatsDisplay();
        }
        
        function savePlayerStats() {
            localStorage.setItem('penaltyKickStats', JSON.stringify(playerStats));
            updateStatsDisplay();
        }
        
        function updateStatsDisplay() {
            const totalGoalsElement = document.getElementById('totalGoals');
            const totalSavesElement = document.getElementById('totalSaves');
            
            if (totalGoalsElement && totalSavesElement) {
                totalGoalsElement.textContent = playerStats.totalGoals;
                totalSavesElement.textContent = playerStats.totalSaves;
            }
        }
        
        function createSkinGrid() {
            skinGrid.innerHTML = '';
            
            skins.forEach(skin => {
                const isUnlocked = playerStats.totalGoals >= skin.requirement;
                const isActive = playerStats.currentSkin === skin.id;
                
                const skinItem = document.createElement('div');
                skinItem.className = `skin-item ${isUnlocked ? '' : 'locked'} ${isActive ? 'active' : ''}`;
                skinItem.dataset.skinId = skin.id;
                
                const skinPreview = document.createElement('img');
                skinPreview.className = 'skin-preview';
                skinPreview.src = skin.file;
                skinPreview.alt = skin.name;
                
                const skinName = document.createElement('div');
                skinName.className = 'skin-name';
                skinName.textContent = skin.name;
                
                const skinRequirement = document.createElement('div');
                skinRequirement.className = 'skin-requirement';
                skinRequirement.textContent = `Required: ${skin.requirement} goals`;
                
                skinItem.appendChild(skinPreview);
                skinItem.appendChild(skinName);
                skinItem.appendChild(skinRequirement);
                
                if (isUnlocked) {
                    skinItem.addEventListener('click', () => {
                        selectSkin(skin.id);
                    });
                }
                
                skinGrid.appendChild(skinItem);
            });
        }
        
        function selectSkin(skinId) {
            playerStats.currentSkin = skinId;
            savePlayerStats();
            
            document.querySelectorAll('.skin-item').forEach(item => {
                item.classList.toggle('active', item.dataset.skinId === skinId);
            });
            
            const selectedSkin = skins.find(skin => skin.id === skinId);
            if (selectedSkin) {
                images.thekicker = new Image();
                images.thekicker.src = selectedSkin.file;
            }
        }
        
        function initSkinSystem() {
            const skinButton = document.getElementById('skinButton');
            const skinPanel = document.getElementById('skinPanel');
            const closeSkinPanel = document.getElementById('closeSkinPanel');
            
            if (skinButton && skinPanel && closeSkinPanel) {
                skinButton.addEventListener('click', () => {
                    const isVisible = skinPanel.style.display === 'block';
                    skinPanel.style.display = isVisible ? 'none' : 'block';
                    
                    if (!isVisible) {
                        createSkinGrid();
                    }
                });
                
                closeSkinPanel.addEventListener('click', () => {
                    skinPanel.style.display = 'none';
                });
            } else {
                console.warn("Skin system UI elements not found!");
            }
        }
        
        function checkFootCollision(kickerSprite, ballSprite) {
            const footCenterX = kickerSprite.x + kickerSprite.width / 2;
            const footCenterY = kickerSprite.y + kickerSprite.height * 0.9;
            const footRadius = kickerSprite.width * 0.2;
            
            const ballCenterX = ballSprite.x + ballSprite.width / 2;
            const ballCenterY = ballSprite.y + ballSprite.height / 2;
            
            const distanceX = footCenterX - ballCenterX;
            const distanceY = footCenterY - ballCenterY;
            const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);
            
            return distance < footRadius;
        }
        
        function kickBall() {
            const kickerCenterX = kicker.x + kicker.width / 2;
            const ballCenterX = ball.x + ball.width / 2;
            const horizontalDirection = (ballCenterX - kickerCenterX) / 100;
            
            ballVelocity.x = horizontalDirection * 25;
            ballVelocity.y = -18;
            ballInMotion = true;
            
            
            if (Math.random() < 0.15) {
                ballVelocity.curve = (Math.random() - 0.5) * 0.5;
            }
        }
        
        function startKeeperDive() {
            if (keeperHasDived) return;
            
            keeperDiving = true;
            keeperHasDived = true;
            
            const ballCenterX = ball.x + ball.width / 2;
            const goalCenterX = sprites.goal.x + sprites.goal.width / 2;
            
            const diveChoice = Math.random();
            const diveDistance = 80;
            const diveYOffset = 30;
            
            if (diveChoice < 0.33) {
                keeper.x -= diveDistance;
                keeper.y += diveYOffset;
                keeperRotation = -Math.PI / 2;
                console.log('Keeper diving LEFT!');
            } else if (diveChoice < 0.66) {
                keeper.y += diveYOffset / 2;
                keeperRotation = 0;
                console.log('Keeper staying CENTER!');
            } else {
                keeper.x += diveDistance;
                keeper.y += diveYOffset;
                keeperRotation = Math.PI / 2;
                console.log('Keeper diving RIGHT!');
            }
            
            keeper.x = Math.max(sprites.goal.x - 100, Math.min(keeper.x, sprites.goal.x + sprites.goal.width - keeper.width + 100));
            keeper.y = Math.max(sprites.goal.y, Math.min(keeper.y, sprites.goal.y + sprites.goal.height + 50));
            
            console.log(`Keeper action! New position X: ${keeper.x}, Y: ${keeper.y}`);
        }
        
        function updateKeeper() {
            if (!ballInMotion && !keeperHasDived && gameState === 'TEAM_A_KICK') {
                const goalCenterX = sprites.goal.x + sprites.goal.width / 2 - keeper.width / 2;
                const distanceFromCenter = keeper.x - goalCenterX;
                
                if (Math.abs(distanceFromCenter) < 80) {
                    keeper.x += keeperAIDirection * keeperAISpeed;
                } else {
                    keeperAIDirection = distanceFromCenter > 0 ? -1 : 1;
                    keeper.x += keeperAIDirection * keeperAISpeed;
                }
                
                if (Math.random() < 0.05) {
                    keeperAIDirection *= -1;
                }
                
                keeperHopOffset += keeperHopDirection * 0.4;
                if (keeperHopOffset > 6) {
                    keeperHopDirection = -1;
                } else if (keeperHopOffset < -2) {
                    keeperHopDirection = 1;
                }
                keeper.y = keeperOriginalY + keeperHopOffset;
                
                const ballMoved = Math.abs(ball.x - ballStartPosition.x) > 0.1 || Math.abs(ball.y - ballStartPosition.y) > 0.1;
                if (ballMoved && !keeperDiving) {
                    console.log('Ball moved! AI keeper diving...');
                    startKeeperDive();
                }
            }
        }
        
        function drawSprite(sprite, customImage = null) {
            const img = customImage || images[sprite.image];
            if (img && img.complete) {
                if (sprite === keeper && keeperDiving && keeperRotation !== 0) {
                    ctx.save();
                    const centerX = sprite.x + sprite.width / 2;
                    const centerY = sprite.y + sprite.height / 2;
                    ctx.translate(centerX, centerY);
                    ctx.rotate(keeperRotation);
                    ctx.drawImage(img, -sprite.width / 2, -sprite.height / 2, sprite.width, sprite.height);
                    ctx.restore();
                } else {
                    ctx.drawImage(img, sprite.x, sprite.y, sprite.width, sprite.height);
                }
            } else {
                ctx.fillStyle = sprite.image === 'theball' ? '#000' : 
                               sprite.image === 'thekeeper' ? '#FF0000' : 
                               sprite.image === 'thekicker' ? '#0000FF' : '#FFF';
                
                if (sprite === keeper && keeperDiving && keeperRotation !== 0) {
                    ctx.save();
                    const centerX = sprite.x + sprite.width / 2;
                    const centerY = sprite.y + sprite.height / 2;
                    ctx.translate(centerX, centerY);
                    ctx.rotate(keeperRotation);
                    ctx.fillRect(-sprite.width / 2, -sprite.height / 2, sprite.width, sprite.height);
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(-sprite.width / 2, -sprite.height / 2, sprite.width, sprite.height);
                    ctx.restore();
                } else {
                    ctx.fillRect(sprite.x, sprite.y, sprite.width, sprite.height);
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(sprite.x, sprite.y, sprite.width, sprite.height);
                }
            }
        }
        
        function drawGoal() {
            if (images.thegoal && images.thegoal.complete) {
                ctx.drawImage(images.thegoal, sprites.goal.x, sprites.goal.y, sprites.goal.width, sprites.goal.height);
            } else {
                ctx.fillStyle = '#FFF';
                ctx.fillRect(sprites.goal.x, sprites.goal.y, sprites.goal.width, sprites.goal.height);
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 5;
                ctx.strokeRect(sprites.goal.x, sprites.goal.y, sprites.goal.width, sprites.goal.height);
                
                ctx.fillStyle = '#FFF';
                ctx.fillRect(sprites.goal.x - 10, sprites.goal.y, 10, sprites.goal.height);
                ctx.fillRect(sprites.goal.x + sprites.goal.width, sprites.goal.y, 10, sprites.goal.height);
                ctx.fillRect(sprites.goal.x - 10, sprites.goal.y - 10, sprites.goal.width + 20, 10);
            }
        }
        
        function checkGoal() {
            const goalHitboxX = sprites.goal.x + sprites.goal.scaledHitboxOffsetX;
            const goalHitboxY = sprites.goal.y + sprites.goal.scaledHitboxOffsetY;
            
            return ball.x + ball.width > goalHitboxX && 
                   ball.x < goalHitboxX + sprites.goal.scaledHitboxWidth &&
                   ball.y + ball.height > goalHitboxY && 
                   ball.y < goalHitboxY + sprites.goal.scaledHitboxHeight;
        }
        
        function checkCollision(obj1, obj2) {
            let obj1X = obj1.x, obj1Y = obj1.y, obj1W = obj1.width, obj1H = obj1.height;
            let obj2X = obj2.x, obj2Y = obj2.y, obj2W = obj2.width, obj2H = obj2.height;
            
            if (obj2 === keeper) {
                obj2X += sprites.keeper.scaledHitboxOffsetX;
                obj2Y += sprites.keeper.scaledHitboxOffsetY;
                obj2W = sprites.keeper.scaledHitboxWidth;
                obj2H = sprites.keeper.scaledHitboxHeight;
            }
            
            return obj1X < obj2X + obj2W &&
                   obj1X + obj1W > obj2X &&
                   obj1Y < obj2Y + obj2H &&
                   obj1Y + obj1H > obj2Y;
        }
        
        function drawHitboxes() {
            ctx.save();
            ctx.lineWidth = 2;
            
            ctx.strokeStyle = '#00FF00';
            ctx.strokeRect(ball.x, ball.y, ball.width, ball.height);
            ctx.fillStyle = 'rgba(0, 255, 0, 0.1)';
            ctx.fillRect(ball.x, ball.y, ball.width, ball.height);
            
            const goalHitboxX = sprites.goal.x + sprites.goal.scaledHitboxOffsetX;
            const goalHitboxY = sprites.goal.y + sprites.goal.scaledHitboxOffsetY;
            ctx.strokeStyle = '#0000FF';
            ctx.strokeRect(goalHitboxX, goalHitboxY, sprites.goal.scaledHitboxWidth, sprites.goal.scaledHitboxHeight);
            ctx.fillStyle = 'rgba(0, 0, 255, 0.1)';
            ctx.fillRect(goalHitboxX, goalHitboxY, sprites.goal.scaledHitboxWidth, sprites.goal.scaledHitboxHeight);
            
            const keeperHitboxX = keeper.x + sprites.keeper.scaledHitboxOffsetX;
            const keeperHitboxY = keeper.y + sprites.keeper.scaledHitboxOffsetY;
            ctx.strokeStyle = '#FF0000';
            ctx.strokeRect(keeperHitboxX, keeperHitboxY, sprites.keeper.scaledHitboxWidth, sprites.keeper.scaledHitboxHeight);
            ctx.fillStyle = 'rgba(255, 0, 0, 0.1)';
            ctx.fillRect(keeperHitboxX, keeperHitboxY, sprites.keeper.scaledHitboxWidth, sprites.keeper.scaledHitboxHeight);
            
            if (!ballInMotion) {
                ctx.strokeStyle = '#FFFF00';
                ctx.strokeRect(kicker.x, kicker.y, kicker.width, kicker.height);
                ctx.fillStyle = 'rgba(255, 255, 0, 0.1)';
                ctx.fillRect(kicker.x, kicker.y, kicker.width, kicker.height);
                
                const footCenterX = kicker.x + kicker.width / 2;
                const footCenterY = kicker.y + kicker.height * 0.9;
                const footRadius = kicker.width * 0.2;
                
                ctx.strokeStyle = '#FF8800';
                ctx.beginPath();
                ctx.arc(footCenterX, footCenterY, footRadius, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.fillStyle = 'rgba(255, 136, 0, 0.2)';
                ctx.fill();
                
                const kickerCenterX = kicker.x + kicker.width / 2;
                const ballCenterX = ball.x + ball.width / 2;
                const kickDirection = ballCenterX - kickerCenterX;
                
                if (Math.abs(kickDirection) > 10) {
                    ctx.strokeStyle = kickDirection < 0 ? '#FF0000' : '#00FF00';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    const arrowStartX = ball.x + ball.width / 2;
                    const arrowStartY = ball.y;
                    const arrowLength = 80;
                    const arrowEndX = arrowStartX + (kickDirection > 0 ? arrowLength : -arrowLength);
                    const arrowEndY = arrowStartY - 60;
                    
                    ctx.moveTo(arrowStartX, arrowStartY);
                    ctx.lineTo(arrowEndX, arrowEndY);
                    ctx.stroke();
                    
                    const headSize = 15;
                    ctx.beginPath();
                    if (kickDirection > 0) {
                        ctx.moveTo(arrowEndX, arrowEndY);
                        ctx.lineTo(arrowEndX - headSize, arrowEndY - headSize);
                        ctx.moveTo(arrowEndX, arrowEndY);
                        ctx.lineTo(arrowEndX - headSize, arrowEndY + headSize);
                    } else {
                        ctx.moveTo(arrowEndX, arrowEndY);
                        ctx.lineTo(arrowEndX + headSize, arrowEndY - headSize);
                        ctx.moveTo(arrowEndX, arrowEndY);
                        ctx.lineTo(arrowEndX + headSize, arrowEndY + headSize);
                    }
                    ctx.stroke();
                    
                    ctx.fillStyle = kickDirection < 0 ? '#FF0000' : '#00FF00';
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(kickDirection > 0 ? 'KICK RIGHT' : 'KICK LEFT', arrowEndX, arrowEndY - 20);
                }
            }
            
            ctx.restore();
        }
        
        function drawBallShadow() {
            ctx.save();
            
            const shadowOffsetX = ball.x + ball.width / 2;
            const shadowOffsetY = ball.y + ball.height + 0;
            const shadowWidth = ball.width * 0.8;
            const shadowHeight = ball.height * 0.3;
            
            const gradient = ctx.createRadialGradient(
                shadowOffsetX, shadowOffsetY, 0,
                shadowOffsetX, shadowOffsetY, shadowWidth / 2
            );
            gradient.addColorStop(0, 'rgba(0, 0, 0, 0.4)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            
            ctx.fillStyle = gradient;
            
            ctx.beginPath();
            ctx.ellipse(
                shadowOffsetX, 
                shadowOffsetY, 
                shadowWidth / 2, 
                shadowHeight / 2, 
                0, 0, 2 * Math.PI
            );
            ctx.fill();
            
            ctx.restore();
        }
        
        function draw() {
            ctx.fillStyle = '#228B22';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const penaltyBoxWidth = 800 * scaleX;
            const penaltyBoxHeight = 150 * scaleY;
            const penaltyBoxX = (canvas.width - penaltyBoxWidth) / 2;
            const penaltyBoxY = 270 * scaleY;
            
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 6 * Math.min(scaleX, scaleY);
            ctx.strokeRect(penaltyBoxX, penaltyBoxY, penaltyBoxWidth, penaltyBoxHeight);
            
            drawGoal();
            
            drawBallShadow();
            
            drawSprite(ball);
            
            drawSprite(keeper);
            
            if (!ballInMotion) {
                drawSprite(kicker);
            }
            
            if (showHitboxes) {
                drawHitboxes();
            }
        }
        
        function updateGameInfo() {
            const info = document.getElementById('gameInfo');
            const instructions = document.getElementById('instructions');
            
            switch(gameState) {
                case 'TEAM_A_KICK':
                    info.textContent = `Round ${round} - Your turn to kick! (vs AI Goalkeeper)`;
                    instructions.textContent = 'Drag kicker LEFT of ball = kick RIGHT, RIGHT of ball = kick LEFT';
                    break;
                case 'TEAM_A_GK':
                    info.textContent = `Round ${round} - Your turn to defend! (vs AI Kicker)`;
                    instructions.textContent = 'Drag keeper DOWN to dive! Position LEFT/CENTER/RIGHT first!';
                    break;
                case 'TEAM_B_KICK':
                    info.textContent = `Round ${round} - Unused state`;
                    instructions.textContent = 'This should not appear';
                    break;
                case 'TEAM_B_GK':
                    info.textContent = `Round ${round} - Unused state`;
                    instructions.textContent = 'This should not appear';
                    break;
                case 'GAME_OVER':
                    const winner = scoreA > scoreB ? 'You' : scoreB > scoreA ? 'AI' : 'Nobody';
                    info.textContent = `Game Over! ${winner} wins!`;
                    instructions.textContent = 'Refresh to play again!';
                    break;
            }
        }
        
        function initGame() {
            try {
                loadPlayerStats();
            } catch (e) {
                console.error("Error loading player stats:", e);
            }
            
            resizeCanvas();
            document.getElementById('instructions').textContent = 'Drag the kicker to the ball to shoot!';
            updateGameInfo();
            ballStartPosition = { x: sprites.ball.x, y: sprites.ball.y };
            keeperOriginalY = sprites.keeper.y;
            
            initSkinSystem();
            
            gameLoop();
        }
        
        function resetPositions() {
            ball = { ...sprites.ball };
            keeper = { ...sprites.keeper };
            kicker = { ...sprites.kicker };
            ballVelocity = { x: 0, y: 0 };
            ballInMotion = false;
            kickTimer = 0;
            gkTimer = 0;
            keeperDiving = false;
            keeperDiveDirection = { x: 0, y: 0 };
            keeperHasDived = false;
            playerKeeperStartY = keeper.y;
            keeperAIDirection = Math.random() > 0.5 ? 1 : -1;
            ballStartPosition = { x: ball.x, y: ball.y };
            keeperHopOffset = 0;
            keeperOriginalY = keeper.y;
            keeperRotation = 0;
        }
        
        function nextTurn() {
            setTimeout(() => {
                switch(gameState) {
                    case 'TEAM_A_KICK':
                        gameState = 'TEAM_A_GK';
                        break;
                    case 'TEAM_A_GK':
                        round++;
                        if (round > maxRounds) {
                            gameState = 'GAME_OVER';
                        } else {
                            gameState = 'TEAM_A_KICK';
                        }
                        break;
                }
                resetPositions();
                updateGameInfo();
            }, 2000);
        }
        
        function simulateKick() {
            const angle = (Math.random() - 0.5) * 3.0;
            const power = (12 + Math.random() * 6) * Math.min(scaleX, scaleY);
            
            ballVelocity.x = Math.sin(angle) * power;
            ballVelocity.y = -power;
            ballInMotion = true;
            
            
            if (Math.random() < 0.1) {
                ballVelocity.curve = (Math.random() - 0.5) * 0.5;
            }
        }
        
        function updateBall() {
            if (!ballInMotion) return;
            
            ball.x += ballVelocity.x;
            ball.y += ballVelocity.y;
            
            if (ballVelocity.curve) {
                ballVelocity.x += ballVelocity.curve;
            }
            
            if (!keeperHasDived && gameState === 'TEAM_A_GK') {
                const ballToGoalDistance = ball.y - (sprites.goal.y + sprites.goal.height);
                if (ballToGoalDistance < 150) {
                    keeperDiving = true;
                    keeperHasDived = true;
                    keeperRotation = 0;
                    console.log('Emergency dive! Player waited too long.');
                }
            }
            
            if (checkGoal()) {
                ballInMotion = false;
                if (gameState === 'TEAM_A_KICK') {
                    scoreA++;
                    document.getElementById('scoreA').textContent = scoreA;
                    console.log('Player scored!');
                    
                    try {
                        playerStats.totalGoals++;
                        savePlayerStats();
                        checkUnlocks();
                    } catch (e) {
                        console.error("Error updating player stats:", e);
                    }
                } else if (gameState === 'TEAM_A_GK') {
                    scoreB++;
                    document.getElementById('scoreB').textContent = scoreB;
                    console.log('AI scored!');
                }
                nextTurn();
                return;
            }
            
            if (checkCollision(ball, keeper)) {
                ballInMotion = false;
                console.log('Goalkeeper saved the ball!');
                
                if (gameState === 'TEAM_A_GK') {
                    playerStats.totalSaves++;
                    savePlayerStats();
                    checkUnlocks();
                }
                
                nextTurn();
                return;
            }
            
            if (ball.x < 0 || ball.x > canvas.width - ball.width || 
                ball.y < 0 || ball.y > canvas.height - ball.height) {
                ballInMotion = false;
                console.log('Ball went out of bounds!');
                nextTurn();
            }
        }
        
        function checkUnlocks() {
            const newUnlocks = skins.filter(skin => 
                playerStats.totalGoals >= skin.requirement && 
                !localStorage.getItem(`skin_${skin.id}_unlocked`)
            );
            
            if (newUnlocks.length > 0) {
                newUnlocks.forEach(skin => {
                    localStorage.setItem(`skin_${skin.id}_unlocked`, 'true');
                    alert(`ðŸŽ‰ New skin unlocked: ${skin.name}! ðŸŽ‰`);
                });
            }
        }
        
        function gameLoop() {
            if (gameState === 'TEAM_A_GK' && !ballInMotion) {
                gkTimer++;
                if (gkTimer > 300) {
                    simulateKick();
                    gkTimer = 0;
                }
            }
            
            updateBall();
            updateKeeper();
            draw();
            requestAnimationFrame(gameLoop);
        }
        
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            if (ballInMotion) return;
            
            if (gameState === 'TEAM_A_KICK') {
                if (mouseX >= kicker.x && mouseX <= kicker.x + kicker.width &&
                    mouseY >= kicker.y && mouseY <= kicker.y + kicker.height) {
                    isDragging = true;
                    dragObject = 'kicker';
                    dragStart = { x: mouseX, y: mouseY };
                }
            } else if (gameState === 'TEAM_A_GK') {
                if (mouseX >= keeper.x && mouseX <= keeper.x + keeper.width &&
                    mouseY >= keeper.y && mouseY <= keeper.y + keeper.height) {
                    isDragging = true;
                    dragObject = 'keeper';
                    dragStart = { x: mouseX, y: mouseY };
                    playerKeeperStartY = keeper.y;
                }
            }
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            if (dragObject === 'kicker') {
                kicker.x = mouseX - kicker.width / 2;
                kicker.y = mouseY - kicker.height / 2;
                
                if (!ballInMotion && checkFootCollision(kicker, ball)) {
                    kickBall();
                    kicker.x = sprites.kicker.x;
                    kicker.y = sprites.kicker.y;
                    isDragging = false;
                    dragObject = null;
                }
            } else if (dragObject === 'keeper') {
                const prevY = keeper.y;
                
                const minX = sprites.goal.x - 150;
                const maxX = sprites.goal.x + sprites.goal.width + 150 - keeper.width;
                const minY = sprites.goal.y - 100;
                const maxY = sprites.goal.y + sprites.goal.height + 100 - keeper.height;
                
                keeper.x = Math.max(minX, Math.min(mouseX - keeper.width / 2, maxX));
                keeper.y = Math.max(minY, Math.min(mouseY - keeper.height / 2, maxY));
                
                if (!keeperHasDived && gameState === 'TEAM_A_GK') {
                    const yMovement = keeper.y - playerKeeperStartY;
                    console.log(`Y Movement: ${yMovement}, Threshold: ${diveThreshold}`);
                    
                    if (yMovement > diveThreshold) {
                        keeperDiving = true;
                        keeperHasDived = true;
                        
                        const goalCenterX = sprites.goal.x + sprites.goal.width / 2;
                        const keeperCenterX = keeper.x + keeper.width / 2;
                        
                        if (keeperCenterX < goalCenterX - 30) {
                            keeperRotation = -Math.PI / 2;
                            console.log('Player keeper diving LEFT!');
                        } else if (keeperCenterX > goalCenterX + 30) {
                            keeperRotation = Math.PI / 2;
                            console.log('Player keeper diving RIGHT!');
                        } else {
                            keeperRotation = 0;
                            console.log('Player keeper diving CENTER!');
                        }
                    }
                }
            }
        });
        
        canvas.addEventListener('mouseup', (e) => {
            if (!isDragging) return;
            
            if (dragObject === 'kicker') {
                kicker.x = sprites.kicker.x;
                kicker.y = sprites.kicker.y;
            } else if (dragObject === 'keeper') {
                keeper.x = sprites.keeper.x;
                keeper.y = sprites.keeper.y;
            }
            
            isDragging = false;
            dragObject = null;
        });
        
        window.addEventListener('resize', resizeCanvas);
        
        window.addEventListener('keydown', (e) => {
            if (e.key === 'h' || e.key === 'H') {
                showHitboxes = !showHitboxes;
                console.log('Hitboxes:', showHitboxes ? 'ON' : 'OFF');
            }
        });
        canvas.addEventListener('touchstart', (e) => {
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const mouseX = touch.clientX - rect.left;
            const mouseY = touch.clientY - rect.top;

            if (ballInMotion) return;

            if (gameState === 'TEAM_A_KICK') {
                if (mouseX >= kicker.x && mouseX <= kicker.x + kicker.width &&
                    mouseY >= kicker.y && mouseY <= kicker.y + kicker.height) {
                    isDragging = true;
                    dragObject = 'kicker';
                    dragStart = { x: mouseX, y: mouseY };
                }
            } else if (gameState === 'TEAM_A_GK') {
                if (mouseX >= keeper.x && mouseX <= keeper.x + keeper.width &&
                    mouseY >= keeper.y && mouseY <= keeper.y + keeper.height) {
                    isDragging = true;
                    dragObject = 'keeper';
                    dragStart = { x: mouseX, y: mouseY };
                    playerKeeperStartY = keeper.y;
                }
            }
            e.preventDefault();
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            if (!isDragging) return;
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const mouseX = touch.clientX - rect.left;
            const mouseY = touch.clientY - rect.top;

            if (dragObject === 'kicker') {
                kicker.x = mouseX - kicker.width / 2;
                kicker.y = mouseY - kicker.height / 2;

                if (!ballInMotion && checkFootCollision(kicker, ball)) {
                    kickBall();
                    kicker.x = sprites.kicker.x;
                    kicker.y = sprites.kicker.y;
                    isDragging = false;
                    dragObject = null;
                }
            } else if (dragObject === 'keeper') {
                const minX = sprites.goal.x - 150;
                const maxX = sprites.goal.x + sprites.goal.width + 150 - keeper.width;
                const minY = sprites.goal.y - 100;
                const maxY = sprites.goal.y + sprites.goal.height + 100 - keeper.height;

                keeper.x = Math.max(minX, Math.min(mouseX - keeper.width / 2, maxX));
                keeper.y = Math.max(minY, Math.min(mouseY - keeper.height / 2, maxY));

                if (!keeperHasDived && gameState === 'TEAM_A_GK') {
                    const yMovement = keeper.y - playerKeeperStartY;
                    if (yMovement > diveThreshold) {
                        keeperDiving = true;
                        keeperHasDived = true;
                        const goalCenterX = sprites.goal.x + sprites.goal.width / 2;
                        const keeperCenterX = keeper.x + keeper.width / 2;
                        if (keeperCenterX < goalCenterX - 30) {
                            keeperRotation = -Math.PI / 2;
                        } else if (keeperCenterX > goalCenterX + 30) {
                            keeperRotation = Math.PI / 2;
                        } else {
                            keeperRotation = 0;
                        }
                    }
                }
            }
            e.preventDefault();
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            if (!isDragging) return;
            if (dragObject === 'kicker') {
                kicker.x = sprites.kicker.x;
                kicker.y = sprites.kicker.y;
            } else if (dragObject === 'keeper') {
                keeper.x = sprites.keeper.x;
                keeper.y = sprites.keeper.y;
            }
            isDragging = false;
            dragObject = null;
            e.preventDefault();
        }, { passive: false });

        window.addEventListener('DOMContentLoaded', function() {
            console.log("DOM fully loaded, starting game initialization");
            loadImages();
        });
    </script>
</body>
</html>
